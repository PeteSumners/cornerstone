#!/usr/bin/env python3
"""
Generate C++ font data from atlas.json and atlas.png

Reads the font atlas and generates C++ code with Letter structs
for use in the voxel world generation.

Usage:
  python generate_cpp_font.py --input ../../assets/fonts/default --output ../../wasm/font_data.h
"""

import json
import argparse
from pathlib import Path
from PIL import Image

def load_atlas(atlas_dir):
    """Load atlas.json and atlas.png"""
    atlas_json = atlas_dir / 'atlas.json'
    atlas_png = atlas_dir / 'atlas.png'

    with open(atlas_json, 'r', encoding='utf-8') as f:
        data = json.load(f)

    img = Image.open(atlas_png).convert('RGBA')

    return data, img

def extract_glyph_pixels(img, row, col, glyph_width, glyph_height):
    """Extract pixel data for a single glyph"""
    pixels = []

    start_x = col * glyph_width
    start_y = row * glyph_height

    for y in range(glyph_height):
        row_pixels = []
        for x in range(glyph_width):
            px = img.getpixel((start_x + x, start_y + y))
            # Check alpha channel - if opaque, it's filled
            is_filled = px[3] > 128 if len(px) > 3 else px > 128
            row_pixels.append(1 if is_filled else 0)
        pixels.append(row_pixels)

    return pixels

def generate_cpp_letter(char_code, pixels, glyph_width, glyph_height):
    """Generate C++ code for a single Letter struct"""
    char_name = f"FONT_CHAR_{char_code}"

    # Try to get character name for comment
    try:
        char_display = chr(char_code)
        if char_display.isprintable() and not char_display.isspace():
            comment = f"// '{char_display}'"
        else:
            comment = f"// (char {char_code})"
    except:
        comment = f"// (char {char_code})"

    lines = [f"const Letter {char_name} = {{{glyph_width}, {{  {comment}"]

    for row in pixels:
        row_str = "{" + ",".join(str(p) for p in row) + "}"
        lines.append(f"  {row_str},")

    # Remove trailing comma from last row
    lines[-1] = lines[-1].rstrip(',')
    lines.append("}};")

    return '\n'.join(lines)

def generate_cpp_font(atlas_dir, output_file):
    """Generate complete C++ font header file"""
    print(f"Loading atlas from {atlas_dir}...")
    data, img = load_atlas(atlas_dir)

    metrics = data['metrics']
    glyphs = data['glyphs']

    glyph_width = metrics['glyph_width']
    glyph_height = metrics['glyph_height']

    print(f"Glyph size: {glyph_width}Ã—{glyph_height}")
    print(f"Total glyphs: {len(glyphs)}")

    # Generate header
    header_lines = [
        "// Auto-generated font data",
        "// DO NOT EDIT - Generated by generate_cpp_font.py",
        "",
        "#ifndef FONT_DATA_H",
        "#define FONT_DATA_H",
        "",
        "namespace voxels {",
        "",
        "// Letter structure: width and pixel bitmap",
        "struct Letter {",
        "  int width;",
        f"  bool pixels[{glyph_height}][{glyph_width}];",
        "};",
        "",
        "// Individual letter definitions",
        ""
    ]

    # Generate each letter
    letter_defs = []
    char_codes = sorted([int(code) for code in glyphs.keys()])

    for char_code in char_codes:
        row, col = glyphs[str(char_code)]
        pixels = extract_glyph_pixels(img, row, col, glyph_width, glyph_height)
        letter_def = generate_cpp_letter(char_code, pixels, glyph_width, glyph_height)
        letter_defs.append(letter_def)

    # Generate lookup function
    lookup_lines = [
        "",
        "// Get Letter for a character code",
        "// Returns nullptr if character not found",
        "inline const Letter* getFont(int charCode) {",
        "  switch(charCode) {"
    ]

    for char_code in char_codes:
        lookup_lines.append(f"    case {char_code}: return &FONT_CHAR_{char_code};")

    lookup_lines.extend([
        "    default: return nullptr;",
        "  }",
        "}",
        "",
        "} // namespace voxels",
        "",
        "#endif // FONT_DATA_H"
    ])

    # Combine everything
    full_content = '\n'.join(header_lines) + '\n'.join(letter_defs) + '\n' + '\n'.join(lookup_lines)

    # Write output
    output_path = Path(output_file)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(full_content)

    print(f"\nGenerated {output_path}")
    print(f"  Total characters: {len(char_codes)}")
    print(f"  Character range: {min(char_codes)} - {max(char_codes)}")
    print(f"  File size: {len(full_content)} bytes")

def main():
    parser = argparse.ArgumentParser(
        description='Generate C++ font data from atlas'
    )

    parser.add_argument('--input', type=str,
                        default='../../assets/fonts/default',
                        help='Path to atlas directory (default: ../../assets/fonts/default)')
    parser.add_argument('--output', type=str,
                        default='../../wasm/font_data.h',
                        help='Output C++ header file (default: ../../wasm/font_data.h)')

    args = parser.parse_args()

    atlas_dir = Path(args.input)
    if not atlas_dir.exists():
        print(f"Error: Atlas directory not found: {atlas_dir}")
        return 1

    generate_cpp_font(atlas_dir, args.output)
    return 0

if __name__ == '__main__':
    exit(main())
